## Cloudflare CDN Architecture: Scenarios and Feature Requirements

### I. Overall Architecture & Responsibilities

* **`cdn.domain.net` (Main CDN Entry Point):**
    * **Responsibility:** Primary domain for all CDN traffic.
    * **Cloudflare Features:** Global DDoS protection, Universal SSL/TLS, Caching, WAF, Rate Limiting, Bot Management.
* **`cdn-router` Worker:**
    * **Responsibility:** Routes incoming requests from `cdn.domain.net` to specialized workers (`cdn-downloads`, `cdn-assets`) via Service Bindings based on URL path.
    * **Key Principle:** Does **NOT** perform any signed URL verification or access control logic.
* **`cdn-downloads` Worker:**
    * **Responsibility:** Handles `/downloads/*` requests, retrieves files from R2, and serves them.
    * **Access Control:** Performs signed URL verification for private downloads.
* **`cdn-assets` Worker:**
    * **Responsibility:** Handles `/assets/*`, `/images/*`, `/videos/*` requests, performs image resizing, and serves assets.
    * **Access Control:** Performs signed URL verification for private assets.
* **Go Backend:**
    * **Responsibility:** Generates signed URLs for private content (downloads and assets).
    * **Security:** Holds the secret keys for signing (must match Worker secrets).

---

### II. Core Feature: Signed URLs

**Requirement:** Securely provide temporary, time-limited access to private content.

* **Mechanism:** HMAC-SHA256 signature generated by Go backend, verified by Workers.
* **Go Backend (Generation):**
    * Constructs "string to sign" (e.g., `path:expiry` or `path?query:expiry`).
    * Calculates HMAC-SHA256 signature using a shared secret.
    * Base64 encodes the signature.
    * Appends `exp` (expiration timestamp) and `sig` (base64 signature) as URL query parameters.
    * Returns the full signed URL (e.g., `https://cdn.domain.net/downloads/private.pdf?exp=...&sig=...`) to the client.
* **Workers (`cdn-downloads`, `cdn-assets`) (Verification):**
    * Extract `exp` and `sig` from the incoming request URL.
    * Check for URL expiration.
    * Reconstruct the "string to sign" **EXACTLY** as generated by the Go backend.
    * Use `crypto.subtle.verify()` with the stored Worker secret to validate the signature.
    * If invalid/expired, return `403 Forbidden`.

---

### III. Scenario 1: Flexible Public/Private Object Access (Primary Recommended Approach)

**Requirement:** Some objects are public and do not require signed URLs, while others are private and do.

* **Mechanism:** R2 Custom Object Metadata (`x-amz-meta-public`).
* **Go Backend (Object Upload):**
    * When uploading to R2, set `Metadata: {"public": "true"}` for public objects.
    * For private objects, either set `{"public": "false"}` or omit the `public` metadata key (defaulting to private).
* **Workers (`cdn-downloads`, `cdn-assets`):**
    * **Pre-verification Step:** Before attempting signed URL verification, `head()` the object from R2 to retrieve its metadata.
    * Check `objectHead.customMetadata.public === 'true'`.
    * **Conditional Logic:**
        * If `isPublic` is `true`: Serve the object directly.
        * If `isPublic` is `false`: Proceed with signed URL verification.
    * If `objectHead` is `null` (object not found), return `404 Not Found`.

---

### IV. Scenario 2: Separate Origin for Raw Assets (`asset-cdn.domain.com`)

**Requirement:** Raw assets are stored/served from a dedicated, potentially private, custom domain (`asset-cdn.domain.com`), and the `cdn-assets` worker fetches from it.

* **Go Backend:**
    * Generates signed URLs pointing to `https://cdn.domain.net/assets/...` (client-facing). The Go backend does not need to know about `asset-cdn.domain.com`.
* **`cdn-router` Worker:**
    * Routes traffic for `cdn.domain.net/assets/*` to `cdn-assets`.
* **`cdn-assets` Worker:**
    * **Verification:** Performs signed URL verification (as per Section II) based on the request to `cdn.domain.net`.
    * **Fetching:** After successful verification (or if the asset is public), constructs a URL pointing to `https://asset-cdn.domain.com/...` (e.g., leveraging Cloudflare Images URLs like `https://asset-cdn.domain.com/cdn-cgi/image/...`) and `fetch()`es the asset from there.
    * **Origin Protection Header (Crucial):** Adds a custom, internal secret header (e.g., `X-Internal-Worker-Access`) to the `fetch()` request to `asset-cdn.domain.com`.
* **`asset-cdn.domain.com` (Raw Asset Origin):**
    * **Configuration:** Configured in Cloudflare DNS (proxied/orange-clouded). Backed by a **private R2 bucket** (or other private origin). **MUST NOT be a public R2 bucket.**
    * **Protection (Cloudflare Access Recommended):**
        * **Cloudflare Access Policy:** Apply a policy to `asset-cdn.domain.com` that **only allows requests originating from your `cdn-assets` Worker**. This is best achieved by requiring the `X-Internal-Worker-Access` header (or similar internal authentication).
        * **Alternative (Less Secure):** WAF Custom Rule to block direct requests missing the `X-Internal-Worker-Access` header.
    * **Result:** Direct access attempts to `asset-cdn.domain.com` (bypassing `cdn.domain.net` and the `cdn-assets` Worker) are blocked at Cloudflare's edge by Access policies or WAF rules, ensuring raw assets are never exposed.

---

### V. Security & Operational Requirements

1.  **Secret Management:**
    * All signing secrets (for downloads and assets) **MUST be identical** between the Go backend and the respective Cloudflare Worker environment variables.
    * Secrets **MUST be stored securely** using `wrangler secret put` and never hardcoded or committed to source control.
2.  **Least Privilege:**
    * Workers (and their R2 bindings) should only have permissions necessary for their tasks (e.g., `cdn-downloads` only needs read for `DOWNLOADS_BUCKET`).
    * R2 buckets backing `asset-cdn.domain.com` (if private) should have no public access policies.
3.  **URL Expiration:**
    * Signed URLs should have short, appropriate expiration times to limit the window of vulnerability if a URL is compromised.
4.  **Cloudflare Edge Security:**
    * **WAF:** Implement Custom Rules to pre-filter malicious requests, enforce expected URL parameters for signed content, and protect against common exploits. Utilize Cloudflare's Managed Rulesets.
    * **Rate Limiting:** Apply rules to `cdn.domain.net` (especially private paths) to prevent brute-force attacks and abuse.
    * **Bot Management:** Leverage bot scores in WAF rules to challenge or block automated traffic attempting to access private assets or abuse your CDN.
5.  **Consistency:**
    * The "string to sign" construction logic **MUST be identical** between the Go backend (signing) and the Workers (verifying).
    * HMAC algorithm (SHA-256), key encoding, and signature encoding/decoding (Base64) **MUST be consistent**.
6.  **Error Handling:** Workers should return appropriate HTTP status codes (403, 404, 500) for unauthorized access, not found objects, or internal errors.

---